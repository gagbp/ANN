'''

Encontre os coeficientes a e b da função exponencial y=aebx que melhor se aproxima da seguinte lista de 100 pontos

[(-3.952, 0.732), (-3.92, 0.73), (-3.888, 0.345), (-3.84, 0.659), (-3.712, 0.433), (-3.696, 0.384), (-3.616, 0.352), (-3.504, 0.517), (-3.44, 0.448), (-3.408, 0.806), (-3.376, 0.535), (-3.264, 0.697), (-3.024, 0.503), (-2.88, 0.812), (-2.864, 0.774), (-2.704, 0.52), (-2.672, 1.014), (-2.608, 0.639), (-2.592, 0.9), (-2.576, 0.655), (-2.384, 0.834), (-2.096, 0.821), (-2.0, 0.968), (-1.904, 1.153), (-1.808, 0.891), (-1.792, 1.035), (-1.712, 1.11), (-1.696, 1.184), (-1.68, 1.159), (-1.632, 1.227), (-1.584, 1.228), (-1.504, 1.082), (-1.488, 1.039), (-1.408, 1.056), (-1.296, 1.048), (-1.168, 1.576), (-1.136, 1.412), (-1.04, 1.644), (-0.992, 1.523), (-0.832, 1.75), (-0.816, 1.73), (-0.736, 1.756), (-0.688, 1.669), (-0.64, 1.572), (-0.608, 1.849), (-0.528, 1.565), (-0.432, 1.838), (-0.4, 1.646), (-0.32, 1.904), (-0.256, 2.214), (-0.16, 2.106), (-0.112, 2.254), (-0.032, 2.377), (-0.016, 2.128), (0.048, 2.148), (0.224, 2.56), (0.288, 2.416), (0.352, 2.606), (0.368, 2.627), (0.384, 2.844), (0.4, 2.919), (0.432, 2.964), (0.56, 2.964), (0.64, 2.887), (0.752, 3.092), (0.832, 3.186), (0.864, 3.266), (0.992, 3.478), (1.168, 3.816), (1.28, 4.016), (1.328, 4.296), (1.52, 4.538), (1.552, 4.677), (1.632, 4.824), (1.664, 4.717), (1.76, 5.061), (1.888, 5.484), (2.048, 5.865), (2.16, 5.921), (2.176, 6.085), (2.224, 6.548), (2.288, 6.741), (2.336, 6.601), (2.528, 7.478), (2.56, 7.196), (2.752, 7.94), (2.848, 8.807), (2.944, 9.183), (3.168, 10.064), (3.216, 10.473), (3.248, 10.553), (3.296, 10.415), (3.376, 10.833), (3.408, 11.275), (3.44, 11.559), (3.456, 11.272), (3.504, 11.553), (3.552, 12.059), (3.6, 12.284), (3.744, 13.481)]

'''
import math
import random as r
import matplotlib.pyplot as plt
import numpy as np

a,b = -4,4
entrada = [(-4.0, 0.339), (-3.984, 0.574), (-3.92, 0.579), (-3.904, 0.697), (-3.888, 0.618), (-3.824, 0.666), (-3.728, 0.603), (-3.632, 0.437), (-3.568, 0.736), (-3.552, 0.544), (-3.536, 0.768), (-3.456, 0.766), (-3.44, 0.752), (-3.408, 0.734), (-3.344, 0.509), (-3.328, 0.429), (-3.312, 0.836), (-3.024, 0.755), (-2.992, 0.726), (-2.976, 0.631), (-2.96, 0.638), (-2.928, 0.76), (-2.864, 0.719), (-2.848, 0.928), (-2.656, 0.78), (-2.64, 0.732), (-2.608, 0.768), (-2.576, 0.616), (-2.544, 0.755), (-2.464, 0.882), (-2.384, 0.665), (-2.32, 0.987), (-2.304, 0.849), (-2.256, 0.684), (-2.192, 0.94), (-2.16, 0.782), (-1.872, 0.828), (-1.744, 1.011), (-1.584, 1.032), (-1.52, 1.224), (-1.456, 1.35), (-1.408, 1.109), (-1.312, 1.405), (-1.28, 1.085), (-1.2, 1.341), (-1.184, 1.56), (-1.056, 1.617), (-1.04, 1.224), (-1.024, 1.219), (-0.944, 1.677), (-0.88, 1.561), (-0.864, 1.565), (-0.816, 1.355), (-0.688, 1.504), (-0.608, 1.79), (-0.576, 1.922), (-0.544, 1.865), (-0.496, 1.663), (-0.464, 2.019), (-0.368, 1.935), (-0.304, 1.964), (-0.192, 2.208), (-0.08, 2.316), (0.032, 2.515), (0.064, 2.138), (0.096, 2.273), (0.192, 2.657), (0.368, 2.721), (0.448, 2.741), (0.528, 2.788), (0.72, 2.872), (0.752, 2.94), (0.912, 3.398), (1.024, 3.784), (1.184, 3.697), (1.376, 3.98), (1.488, 4.683), (1.552, 4.412), (1.712, 4.785), (1.792, 4.953), (1.808, 4.967), (2.048, 5.614), (2.176, 6.029), (2.512, 7.342), (2.688, 7.918), (2.72, 8.147), (2.832, 8.386), (2.864, 8.699), (2.912, 8.667), (2.96, 8.823), (3.024, 9.097), (3.056, 9.547), (3.2, 9.939), (3.248, 10.184), (3.376, 11.287), (3.536, 11.754), (3.712, 13.077), (3.84, 14.004), (3.92, 14.478), (4.0, 14.888)]
n = 100
xs = [x for (x,y) in entrada]
ys = [y for (x,y) in entrada]

def modulo(x):
    if x < 0:
        return -x
    return x

def sinal(x):
    if x < 0:
        return -1
    return 1

# x --> x_til = ln(x)
xs_new = [math.log(modulo(x))*sinal(x) for x in xs]
# y --> y_til = ln(y)
ys_new = [math.log(y) for y in ys]
pontos = list(zip(xs_new, ys_new))

# método dos mínimos quadrados para retas
def min_q(pontos):
    n = len(pontos)
    sumxk = sum(x for x, _ in pontos)
    sumxk2 = sum(x ** 2 for x, _ in pontos)
    sumyk = sum(y for _, y in pontos)
    sumykxk = sum(x * y for x, y in pontos)
    A = [[n, sumxk], [sumxk,sumxk2]]
    B = [sumyk, sumykxk]
    coefs = np.linalg.solve(A, B)
    return coefs # a0 e a1

# y_til = a_0 + a_1 + x_til
coefs = min_q(pontos) # [a0, a1]
# def p(x): # <-- a melhor reta
#     # a0 + ai * x
#     return sum(c * x ** i for i, c in enumerate(coefs))

a_ = math.exp(coefs[0])
b_ = coefs[1]
print(a_, b_)

def expo(x): # y = a * exp(b * x) # é a melhor função exponencial
    return a_ * math.exp(b_ * x)

def poten(x): # y = a * x ** b # é a melhor função potência
    # sensível demais ;(
    return a_ * x ** b_

plt.scatter(xs, ys)
h = (b - a) / n

t = [a + i * h for i in range(n)]
yt = [poten(x) for x in t]

plt.plot(t, yt, 'r')
plt.show()

'''
2.196959780348536 0.5942809320139684

[2.3691869702752344]	[0.43788989216962604]
'''
