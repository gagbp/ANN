'''

Encontre os coeficientes a e b da função exponencial y=aebx que melhor se aproxima da seguinte lista de 100 pontos

[(-3.952, 0.732), (-3.92, 0.73), (-3.888, 0.345), (-3.84, 0.659), (-3.712, 0.433), (-3.696, 0.384), (-3.616, 0.352), (-3.504, 0.517), (-3.44, 0.448), (-3.408, 0.806), (-3.376, 0.535), (-3.264, 0.697), (-3.024, 0.503), (-2.88, 0.812), (-2.864, 0.774), (-2.704, 0.52), (-2.672, 1.014), (-2.608, 0.639), (-2.592, 0.9), (-2.576, 0.655), (-2.384, 0.834), (-2.096, 0.821), (-2.0, 0.968), (-1.904, 1.153), (-1.808, 0.891), (-1.792, 1.035), (-1.712, 1.11), (-1.696, 1.184), (-1.68, 1.159), (-1.632, 1.227), (-1.584, 1.228), (-1.504, 1.082), (-1.488, 1.039), (-1.408, 1.056), (-1.296, 1.048), (-1.168, 1.576), (-1.136, 1.412), (-1.04, 1.644), (-0.992, 1.523), (-0.832, 1.75), (-0.816, 1.73), (-0.736, 1.756), (-0.688, 1.669), (-0.64, 1.572), (-0.608, 1.849), (-0.528, 1.565), (-0.432, 1.838), (-0.4, 1.646), (-0.32, 1.904), (-0.256, 2.214), (-0.16, 2.106), (-0.112, 2.254), (-0.032, 2.377), (-0.016, 2.128), (0.048, 2.148), (0.224, 2.56), (0.288, 2.416), (0.352, 2.606), (0.368, 2.627), (0.384, 2.844), (0.4, 2.919), (0.432, 2.964), (0.56, 2.964), (0.64, 2.887), (0.752, 3.092), (0.832, 3.186), (0.864, 3.266), (0.992, 3.478), (1.168, 3.816), (1.28, 4.016), (1.328, 4.296), (1.52, 4.538), (1.552, 4.677), (1.632, 4.824), (1.664, 4.717), (1.76, 5.061), (1.888, 5.484), (2.048, 5.865), (2.16, 5.921), (2.176, 6.085), (2.224, 6.548), (2.288, 6.741), (2.336, 6.601), (2.528, 7.478), (2.56, 7.196), (2.752, 7.94), (2.848, 8.807), (2.944, 9.183), (3.168, 10.064), (3.216, 10.473), (3.248, 10.553), (3.296, 10.415), (3.376, 10.833), (3.408, 11.275), (3.44, 11.559), (3.456, 11.272), (3.504, 11.553), (3.552, 12.059), (3.6, 12.284), (3.744, 13.481)]

'''
import math
import random as r
import matplotlib.pyplot as plt
import numpy as np

a,b = -4,4
entrada = [(-3.952, 0.732), (-3.92, 0.73), (-3.888, 0.345), (-3.84, 0.659), (-3.712, 0.433), (-3.696, 0.384), (-3.616, 0.352), (-3.504, 0.517), (-3.44, 0.448), (-3.408, 0.806), (-3.376, 0.535), (-3.264, 0.697), (-3.024, 0.503), (-2.88, 0.812), (-2.864, 0.774), (-2.704, 0.52), (-2.672, 1.014), (-2.608, 0.639), (-2.592, 0.9), (-2.576, 0.655), (-2.384, 0.834), (-2.096, 0.821), (-2.0, 0.968), (-1.904, 1.153), (-1.808, 0.891), (-1.792, 1.035), (-1.712, 1.11), (-1.696, 1.184), (-1.68, 1.159), (-1.632, 1.227), (-1.584, 1.228), (-1.504, 1.082), (-1.488, 1.039), (-1.408, 1.056), (-1.296, 1.048), (-1.168, 1.576), (-1.136, 1.412), (-1.04, 1.644), (-0.992, 1.523), (-0.832, 1.75), (-0.816, 1.73), (-0.736, 1.756), (-0.688, 1.669), (-0.64, 1.572), (-0.608, 1.849), (-0.528, 1.565), (-0.432, 1.838), (-0.4, 1.646), (-0.32, 1.904), (-0.256, 2.214), (-0.16, 2.106), (-0.112, 2.254), (-0.032, 2.377), (-0.016, 2.128), (0.048, 2.148), (0.224, 2.56), (0.288, 2.416), (0.352, 2.606), (0.368, 2.627), (0.384, 2.844), (0.4, 2.919), (0.432, 2.964), (0.56, 2.964), (0.64, 2.887), (0.752, 3.092), (0.832, 3.186), (0.864, 3.266), (0.992, 3.478), (1.168, 3.816), (1.28, 4.016), (1.328, 4.296), (1.52, 4.538), (1.552, 4.677), (1.632, 4.824), (1.664, 4.717), (1.76, 5.061), (1.888, 5.484), (2.048, 5.865), (2.16, 5.921), (2.176, 6.085), (2.224, 6.548), (2.288, 6.741), (2.336, 6.601), (2.528, 7.478), (2.56, 7.196), (2.752, 7.94), (2.848, 8.807), (2.944, 9.183), (3.168, 10.064), (3.216, 10.473), (3.248, 10.553), (3.296, 10.415), (3.376, 10.833), (3.408, 11.275), (3.44, 11.559), (3.456, 11.272), (3.504, 11.553), (3.552, 12.059), (3.6, 12.284), (3.744, 13.481)]
n = 100
xs = [x for (x,y) in entrada]
ys = [y for (x,y) in entrada]

def modulo(x):
    if x < 0:
        return -x
    return x

def sinal(x):
    if x < 0:
        return -1
    return 1

# x --> x_til = ln(x)
xs_new = [math.log(modulo(x))*sinal(x) for x in xs]
# y --> y_til = ln(y)
ys_new = [math.log(y) for y in ys]
pontos = list(zip(xs_new, ys_new))

# método dos mínimos quadrados para retas
def min_q(pontos):
    n = len(pontos)
    sumxk = sum(x for x, _ in pontos)
    sumxk2 = sum(x ** 2 for x, _ in pontos)
    sumyk = sum(y for _, y in pontos)
    sumykxk = sum(x * y for x, y in pontos)
    A = [[n, sumxk], [sumxk,sumxk2]]
    B = [sumyk, sumykxk]
    coefs = np.linalg.solve(A, B)
    return coefs # a0 e a1

# y_til = a_0 + a_1 + x_til
coefs = min_q(pontos) # [a0, a1]
# def p(x): # <-- a melhor reta
#     # a0 + ai * x
#     return sum(c * x ** i for i, c in enumerate(coefs))

a_ = math.exp(coefs[0])
b_ = coefs[1]
print(a_, b_)

def expo(x): # y = a * exp(b * x) # é a melhor função exponencial
    return a_ * math.exp(b_ * x)

def poten(x): # y = a * x ** b # é a melhor função potência
    # sensível demais ;(
    return a_ * x ** b_

plt.scatter(xs, ys)
h = (b - a) / n

t = [a + i * h for i in range(n)]
yt = [poten(x) for x in t]

plt.plot(t, yt, 'r')
plt.show()

'''
2.196959780348536 0.5942809320139684
'''
